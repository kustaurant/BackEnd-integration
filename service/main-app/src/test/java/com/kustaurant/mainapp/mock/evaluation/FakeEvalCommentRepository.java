package com.kustaurant.mainapp.mock.evaluation;

import com.kustaurant.mainapp.evaluation.comment.domain.EvalComment;
import com.kustaurant.mainapp.evaluation.comment.service.port.EvalCommentRepository;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

public class FakeEvalCommentRepository implements EvalCommentRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(1);
    private final Map<Long, EvalComment> data = new ConcurrentHashMap<>();

    @Override
    public EvalComment save(EvalComment evalComment) {
        if (evalComment.getId() == null || evalComment.getId() == 0) {
            EvalComment newEvalComment = EvalComment.builder()
                    .id(autoGeneratedId.getAndIncrement())
                    .userId(evalComment.getUserId())
                    .restaurantId(evalComment.getRestaurantId())
                    .evaluationId(evalComment.getEvaluationId())
                    .body(evalComment.getBody())
                    .likeCount(evalComment.getLikeCount())
                    .dislikeCount(evalComment.getDislikeCount())
                    .status(evalComment.getStatus())
                    .createdAt(evalComment.getCreatedAt())
                    .updatedAt(evalComment.getUpdatedAt())
                    .build();
            data.put(newEvalComment.getId(), newEvalComment);
            return newEvalComment;
        } else{
            data.put(evalComment.getId(), evalComment);
            return evalComment;
        }
    }

    @Override
    public Optional<EvalComment> findById(Long id) {
        return Optional.ofNullable(data.get(id));
    }

    @Override
    public Optional<EvalComment> findByIdAndRestaurantId(Long evalCommentId, Long restaurantId) {
        EvalComment evalComment = data.get(evalCommentId);
        return (evalComment != null && evalComment.getRestaurantId().equals(restaurantId))
                ? Optional.of(evalComment) : Optional.empty();
    }

    @Override
    public List<EvalComment> findAllByEvaluationIdIn(List<Long> evalIds) {
        Set<Long> idSet = new HashSet<>(evalIds);

        return data.values().stream()
                .filter(c -> idSet.contains(c.getEvaluationId()))
                .toList();
    }
}
